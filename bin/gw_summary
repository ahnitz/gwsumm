#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (C) Duncan Macleod (2013)
#
# This file is part of GWSumm.
#
# GWSumm is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# GWSumm is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GWSumm.  If not, see <http://www.gnu.org/licenses/>.

"""Gravitational-wave interferometer summary information system.

This module provides the command-line interface to the GWSumm package,
allowing generation of detector summary information
"""

import os
import datetime
import optparse
import re
import calendar
import getpass
from multiprocessing import cpu_count

from dateutil.relativedelta import relativedelta

import numpy

from matplotlib import use
use('Agg')

from lal import gpstime

# set matplotlib backend
try:
    from collections import OrderedDict
except ImportError:
    from astropy.utils import OrderedDict

from astropy import units

from gwpy.segments import Segment
from gwpy.time import Time

from gwsumm import (globalv, version)
from gwsumm.mode import *
from gwsumm.config import *
from gwsumm.tabs import *
from gwsumm.utils import *
from gwsumm.state import *

__version__ = version.version
__author__ = 'Duncan Macleod <duncan.macleod@ligo.org>'

# find channels
re_channel = re.compile('[A-Z]\d:[A-Z]+-[A-Z0-9_]+(\.[a-z]+)?(,[a-z\-]+)?\Z')

# XXX HACK: disable colon separator in ConfigParser
GWSummConfigParser.OPTCRE = re.compile(
    r'(?P<option>[^=\s][^=]*)\s*(?P<vi>[=])\s*(?P<value>.*)$')

VERBOSE = False
PROFILE = False

# ----------------------------------------------------------------------------
# Command-line options

usage = 'python -m gwsumm --config-file CONFIG --day YYYYMMDD'

parser = optparse.OptionParser(usage=usage, description=__doc__,
                               formatter=optparse.IndentedHelpFormatter(4))

parser.add_option("-p", "--profile", action="store_true", default=False,
                  help="show second timer with verbose statements, "
                       "default: %default")
parser.add_option("-v", "--verbose", action="store_true", default=False,
                  help="show verbose output, default: %default")
parser.add_option("-V", "--version", action="version",
                  help="show program's version number and exit")
parser.version = __version__

bopts = parser.add_option_group("Basic options")
bopts.add_option('-i', '--ifo', action='store', type='string',
                 metavar='IFO', help="Instrument to process. If this option "
                                     "is set in the [DEFAULT] of any of the "
                                     "INI files, giving it here is redundant.")

copts = parser.add_option_group("Configuration options",
                                "Provide a number of INI-format "
                                "configuration files")
copts.add_option('-f', '--config-file', action='append', type='string',
                 metavar='FILE', default=[],
                 help="INI file for analysis, may be given multiple times")
copts.add_option('--nds', action='store_true', default='guess',
                 help='use NDS as the data source, default: %default')
copts.add_option('-t', '--process-tab', action='append', type='string',
                 default=[], help="process only this tab, can be given "
                                  "multiple times, default: process all.")
copts.add_option('--max-processes', action='store', type='int',
                 default=cpu_count()//2, dest='multiprocess', metavar='N',
                 help="use a maximum of N subprocesses at any time, "
                      "default: %default")
copts.add_option('--single-process', action='store_true', default=False,
                 help="restrict %s to a single process, mainly for debugging "
                      "purposes, default: False" % os.path.basename(__file__))

outopts = parser.add_option_group("Output options")
outopts.add_option('-o', '--output-dir', action='store', type='string',
                   metavar='DIR', default=os.curdir,
                   help="Output directory for summary information, "
                        "default: '%default'")
outopts.add_option('-m', '--html-only', action='store_true', default=False,
                   help="Generate HTML and navigation only, default: %default")
outopts.add_option('-n', '--no-html', action='store_true', default=False,
                   help="Generate only plots and tab summaries, not "
                        "supporting HTML, default: %default. This is useful "
                        "to regenerate a single tab without messing up the "
                        "navigation bar.")

topts = parser.add_option_group("Time mode options",
                                "Choose a stadard time mode, or a GPS "
                                "[start, stop) interval")
topts.add_option("--day", action="store", type="string", metavar='YYYYMMDD',
                 help="day to process.")
topts.add_option("--week", action="store", type="string", metavar="YYYYMMDD",
                 help="week to process (by starting day).")
topts.add_option("--month", action="store", type="string", metavar="YYYYMM",
                 help="month to process.")
topts.add_option("--year", action="store", type="string", metavar="YYYY",
                 help="year to process.")
topts.add_option("-s", "--gps-start-time", action="store", type="int",
                 metavar="GPSSTART", help="GPS start time")
topts.add_option("-e", "--gps-end-time", action="store", type="int",
                 metavar="GPSEND", help="GPS end time")

opts, args = parser.parse_args()

opts.config_file = [fp for csv in opts.config_file for fp in csv.split(',')]

# read configuration file
config = GWSummConfigParser(dict_type=OrderedDict)
config.optionxform = str
if opts.ifo:
    config.set(None, 'ifo', opts.ifo)
config.set(None, 'user', getpass.getuser())
config.read(opts.config_file)
config.files = map(os.path.abspath, opts.config_file)

# parse IFO
try:
    ifo = config.get(DEFAULTSECT, 'ifo')
except NoOptionError:
    raise ValueError("The relevant IFO must be given either from the --ifo "
                     "command-line option, or the [DEFAULT] section of any "
                     "INI file")

# interpolate section names
for section in config.sections():
    if section.startswith('%(ifo)s'):
        s2 = section.replace('%(ifo)s', ifo)
        config._sections[s2] = config._sections.pop(section)

# check time options
N = sum([opts.day is not None, opts.month is not None,
         opts.gps_start_time is not None, opts.gps_end_time is not None])
if N > 1 and not (opts.gps_start_time and opts.gps_end_time):
    raise optparse.OptionValueError("Please give only one of --day, "
                                    "--month, or --gps-start-time and "
                                    "--gps-end-time.")

if opts.day:
    try:
        opts.day = datetime.datetime.strptime(opts.day, "%Y%m%d")
    except ValueError:
        raise optparse.OptionValueError("--day malformed. Please format "
                                        "as YYYYMMDD")
    else:
        opts.gps_start_time = gpstime.utc_to_gps(opts.day)
        opts.gps_end_time = gpstime.utc_to_gps(opts.day +
                                               datetime.timedelta(days=1))
elif opts.week:
    week = opts.week
    try:
        opts.week = datetime.datetime.strptime(opts.week, "%Y%m%d")
    except ValueError:
        raise optparse.OptionValueError("--week malformed. Please format"
                                        " as YYYYMMDD")
    else:
        if config.has_option("calendar", "start-of-week"):
            weekday = getattr(calendar,
                              config.get("calendar", "start-of-week").upper())
            if weekday != opts.week.timetuple().tm_wday:
                msg = ("Cannot process week starting on %s. The "
                       "'start-of-week' option in the [calendar] section "
                       "of the INI file specifies weeks start on %ss."
                       % (week, config.get("calendar", "start-of-week")))
                raise optparse.OptionValueError(msg)
        opts.gps_start_time = gpstime.utc_to_gps(opts.week)
        opts.gps_end_time = gpstime.utc_to_gps(opts.week +
                                               datetime.timedelta(days=7))
# parse month definition
elif opts.month:
    try:
        opts.month = datetime.datetime.strptime(opts.month, "%Y%m")
    except ValueError:
        raise optparse.OptionValueError("--month malformed. Please format"
                                        " as YYYYMM")
    else:
        opts.gps_start_time = gpstime.utc_to_gps(opts.month)
        opts.gps_end_time = gpstime.utc_to_gps(opts.month +
                                               relativedelta(months=1))
elif opts.year:
    try:
        opts.year = datetime.datetime.strptime(opts.year, "%Y")
    except ValueError:
        raise optparse.OptionValueError("--year malformed. Please format"
                                        " as YYYY")
    else:
        opts.gps_start_time = gpstime.utc_to_gps(opts.year)
        opts.gps_end_time = gpstime.utc_to_gps(opts.year +
                                               relativedelta(years=1))
# parse GPS start and stop times
elif opts.gps_start_time or opts.gps_end_time:
    if not (opts.gps_start_time and opts.gps_end_time):
        raise optparse.OptionValueError("Please give both --gps-start-time "
                                        "and --gps-end-time.")
else:
    opts.day = datetime.date(*datetime.datetime.utcnow().timetuple()[:3])
    opts.gps_start_time = int(gpstime.utc_to_gps(opts.day))
    opts.gps_end_time = int(gpstime.utc_to_gps(opts.day +
                                               datetime.timedelta(days=1)))

span = Segment(opts.gps_start_time, opts.gps_end_time)
try:
    config.set('general', 'gps-start-time', str(int(opts.gps_start_time)))
    config.set('general', 'gps-end-time', str(int(opts.gps_end_time)))
except configparser.NoSectionError:
    config.add_section('general')
    config.set('general', 'gps-start-time', str(int(opts.gps_start_time)))
    config.set('general', 'gps-end-time', str(int(opts.gps_end_time)))


starttime = Time(float(opts.gps_start_time), format='gps')
endtime = Time(float(opts.gps_end_time), format='gps')

# set verbose output options
globalv.VERBOSE = opts.verbose
globalv.PROFILE = opts.profile

# set mode and output directory
outdir = opts.output_dir
utc = gpstime.gps_to_utc(opts.gps_start_time)
if opts.day:
    mode = SUMMARY_MODE_DAY
    base = os.path.join('day', utc.strftime('%Y%m%d'))
elif opts.week:
    mode = SUMMARY_MODE_WEEK
    base = os.path.join('week', str(utc.isocalendar()[1]))
elif opts.month:
    mode = SUMMARY_MODE_MONTH
    base = os.path.join('month', utc.strftime('%Y%m'))
elif opts.year:
    mode = SUMMARY_MODE_YEAR
    base = os.path.join('year', utc.strftime('%Y'))
else:
    mode = SUMMARY_MODE_GPS
    base = os.path.join('%d-%d' % (opts.gps_start_time, opts.gps_end_time))

globalv.MODE = mode

# set processing options
if opts.single_process:
    opts.multiprocess = False

# -----------------------------------------------------------------------------
# Setup

vprint("""
------------------------------------------------------------------------------
Welcome to the GW summary information system command-line interface
------------------------------------------------------------------------------

You have selected %s mode.
Start time %s (%s)
End time: %s (%s)
""" % (MODE_NAME[mode], starttime.utc.iso, starttime.gps,
       endtime.utc.iso, endtime.gps))

# Load custom units
try:
    customunits = config.nditems('units')
except configparser.NoSectionError:
    pass
else:
    new_ = []
    for unit, b in customunits:
        if b.lower() == 'dimensionless':
            b = ''
        new_.append(units.def_unit([unit], units.Unit(b)))
    units.add_enabled_units(new_)

if not opts.html_only:
    # parse channel grouns into individual sections
    for section in config.sections():
        if re.match('channels[-\s]', section):
            items = dict(config.nditems(section))
            try:
                names = split_channels(items.pop('channels'))
            except KeyError:
                raise NoOptionError('channels', section)
            for name in names:
                name = name.strip(' \n')
                if not config.has_section(name):
                    config.add_section(name)
                for key, val in items.iteritems():
                    if not config.has_option(name, key):
                        config.set(name, key, val)

    # read custom channel definitions
    for section in config.sections():
        if re_channel.match(section):
            channel = get_channel(section)
            for key, val in nat_sorted(config.nditems(section),
                                       key=lambda x: x[0]):
                key = re_cchar.sub('_', key.rstrip())
                if key.isdigit():
                    if not hasattr(channel, 'bitmask'):
                        channel.bitmask = []
                    while len(channel.bitmask) < int(key):
                        channel.bitmask.append(None)
                    channel.bitmask.append(val)
                else:
                    try:
                        setattr(channel, key, eval(val.rstrip()))
                    except NameError:
                        setattr(channel, key, val.rstrip())

# read states
load_states(config)

# build directories
mkdir(outdir)
os.chdir(outdir)
plotdir = os.path.join(base, 'plots')
mkdir(plotdir)

# -----------------------------------------------------------------------------
# Read HTML configuration

css = [cval for (key, cval) in config.items('html') if re.match('css\d+', key)]
javascript = [jval for (key, jval) in config.items('html') if
              re.match('javascript\d+', key)]

# -----------------------------------------------------------------------------
# Read tabs

# read all tabs
alltabs = []
for section in filter(lambda n: re.match('tab[-\s]', n),
                      config.sections()):
    if len(opts.process_tab) == 0 or section[4:] in opts.process_tab:
        tab = SummaryTab.from_ini(config, section, plotdir=plotdir, base=base)
        alltabs.append(tab)

# sort tabs into hierarchical list
tabs = {}
# 1. Assume all tabs without parents are parents themselves
for tab in filter(lambda tab: tab.parent is None, alltabs):
    tabs[tab.name] = tab
# 2. All remaining tabs without a defined parent define that parent
# 3. Sort all tabs into their parent sets
for tab in filter(lambda tab: tab.parent is not None, alltabs):
    tabs.setdefault(tab.parent, SummaryTab(tab.parent))
    tab.parent = tabs[tab.parent]
    tab.parent.add_child(tab)

tabs = tabs.values()

# write config page
about = AboutTab('About', parent=None, states=[globalv.STATES[ALLSTATE]],
                 base=base)
if not opts.no_html:
    mkdir(about.path)
    about.build_html(css=css, js=javascript, tabs=tabs, config=config.files)


# -----------------------------------------------------------------------------
# Process all tabs

# sort tabs by 'Summary', then lower case only, then everything else
_sort_tabs = lambda tab: (tab.name == 'Summary' and 1 or
                          tab.name.islower() and tab.name.upper() or
                          tab.name.lower())

tabs.sort(key=_sort_tabs)
for tab in tabs:
    tab.children.sort(key=_sort_tabs)

alltabs.sort(key=_sort_tabs, reverse=True)
for tab in alltabs:
    mkdir(tab.href)
    if not opts.html_only:
        tab.process(config=config, nds=opts.nds,
                    multiprocess=opts.multiprocess)
    page = tab.build_html(css=css, js=javascript, tabs=tabs,
                          about=about.index, writedata=not opts.html_only,
                          writehtml=not opts.no_html)

# -----------------------------------------------------------------------------
# Finalise

vprint("""
------------------------------------------------------------------------------
All done. Thank you.
------------------------------------------------------------------------------
""")
